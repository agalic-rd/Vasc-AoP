```{r}
source(here::here("src", "setup.R"), echo = FALSE)
```

<!---------------------------------------------------------->
<!---------------------------------------------------------->
# I. Data
***

```{r}
(supplementary_data <- load_supplementary_data())
```

```{r}
(vasc_data <- load_pcr_data(target = "vasc", reprocess = TRUE))
```

<!---------------------------------------------------------->
<!---------------------------------------------------------->
# II. Model fitting
***

Let's define the model we will fit to each `Gene`'s `DCq` data. 

Here, we will fit a simple Linear Model, which is largely similar to running a t-test between both conditions:

```{r}
vasc_model <- function(data) {
  glmmTMB(dcq ~ condition, family = gaussian("identity"), data = data, contrasts = list(condition = "contr.sum"))
}
```

Now, let's fit said model to each `Gene`'s data, for a given `Stage` and `Layer`:

```{r}
compute_fold_change <- function(mod) {
  return(
    get_data(mod)
    |> select(condition, dcq)
    |> pivot_wider(names_from = condition, values_from = dcq, values_fn = mean)
    |> summarize(fold = 2**(-1 * (IH - N)))
    |> pull(fold)
  )
}
```

```{r}
(vasc_data$models <- vasc_data$clean
  |> group_split(stage, gene)
  |> map_dfr(
    \(d) summarize(d, mod = pick(condition, dcq) |> vasc_model() |> list(), .by = c(stage, gene)), 
    .progress = "Fitting models:"
  )
  |> filter(!has_na_coefs(mod)) # Removing models that did not fit properly
  |> mutate(fold = map_dbl(mod, compute_fold_change)) # Adding the Fold change
  |> select(stage, gene, fold, mod)
)
```

<!---------------------------------------------------------->
<!---------------------------------------------------------->
# III. Model analysis
***

## Predictions

For each model we fit, we can then extract the CI and p_value for the relevant contrasts, and use those to establish if a `Gene` was up or down-regulated:

```{r}
get_emmeans_data <- function(mod) {
  return(
    emmeans(mod, specs = "condition", type = "response")
    |> contrast(method = "pairwise", adjust = "none", infer = TRUE)
    |> as.data.frame()
    |> pivot_wider(names_from = contrast, values_from = estimate)
    |> select(last_col(), LCB = lower.CL, UCB = upper.CL, p_value = p.value)
    |> mutate(across(where(is.character), \(x) na_if(x, "NaN")))
  )
}
```

```{r}
(vasc_data$predictions <- vasc_data$models
  |> group_split(stage, gene)
  |> map_dfr(\(d) mutate(d, get_emmeans_data(mod[[1]])), .progress = "Extracting model predictions:")
  |> filter(!is.na(p_value))
  |> mutate(expression = get_regulation_type(fold, p_value))
  |> select(stage, gene, fold, expression, matches("-|/"), LCB, UCB, p_value)
)
```

## Gene regulation timeline

To get a better idea of how each `Gene`'s regulation changes through time, we can plot a timeline of their expression, split by `Layer` and `Pathway`.

```{r fig.width = 12, fig.height = 8}
(
  vasc_data$predictions 
  |> left_join(supplementary_data$gene_data$ref, join_by(gene))
  |> filter(p_value <= .05)
  |> select(stage, gene, fold, p_value, expression, pathway, effect)
  |> mutate(effect = case_when(
      str_detect(expression, "Downregulated") & effect == "Pro" ~ "Anti",
      str_detect(expression, "Downregulated") & effect == "Anti" ~ "Pro",
      .default = effect
    )
  )
  |> make_fold_timeline_plot(facet_rows = "pathway", color_by = "effect", size_boost = 1.5)
  |> save_png("vasc_timeline", subfolder = "PCR")
)
```

## Temporo-functional heatmap

```{r fig.height = 8, fig.width = 15}
((vasc_data$predictions |>
  filter(p_value <= .05) |>
  left_join(supplementary_data$gene_data$fx, by = "gene", relationship = "many-to-many") |>
  select(stage, gene, fold, p_value, fx, effect, abb) |> 
  make_heatmap(xaxis = "abb", facet = "stage")) + labs(x = "Function")
) |> save_png("vasc_heatmap", subfolder = "PCR", height = 8, width = 15)
```

# Sankey

```{r}
# Library
library(networkD3)
library(dplyr)

# Make a connection data frame
links <- data.frame(
  source = c("group_A","group_A", "group_B", "group_C", "group_C", "group_E"), 
  target = c("group_C","group_D", "group_E", "group_F", "group_G", "group_H"), 
  value = c(2,3, 2, 3, 1, 3)
)
 
# From these flows we need to create a node data frame: it lists every entities involved in the flow
nodes <- data.frame(
  name=c(as.character(links$source), as.character(links$target)) %>% 
    unique()
)

# With networkD3, connection must be provided using id, not using real name like in the links dataframe.. So we need to reformat it.
links$IDsource <- match(links$source, nodes$name)-1 
links$IDtarget <- match(links$target, nodes$name)-1
 
# prepare color scale: I give one specific color for each node.
my_color <- 'd3.scaleOrdinal() .domain(["group_A", "group_B","group_C", "group_D", "group_E", "group_F", "group_G", "group_H"]) .range(["blue", "blue" , "blue", "red", "red", "yellow", "purple", "purple"])'
 
# Make the Network. I call my colour scale with the colourScale argument
p <- sankeyNetwork(Links = links, Nodes = nodes, Source = "IDsource", Target = "IDtarget", 
              Value = "value", NodeID = "name", colourScale=my_color)
p

# save the widget
# library(htmlwidgets)
# saveWidget(p, file=paste0( getwd(), "/HtmlWidget/sankeyColor1.html"))
```


